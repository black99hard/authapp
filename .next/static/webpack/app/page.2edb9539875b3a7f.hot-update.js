"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/auth.ts":
/*!*********************!*\
  !*** ./lib/auth.ts ***!
  \*********************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthService: () => (/* binding */ AuthService)\n/* harmony export */ });\n/* harmony import */ var bcryptjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! bcryptjs */ \"(app-pages-browser)/./node_modules/bcryptjs/index.js\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! crypto */ \"(app-pages-browser)/./node_modules/next/dist/compiled/crypto-browserify/index.js\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_1__);\n\n\n// In-memory storage for prototype\nconst users = new Map();\nconst otpSessions = new Map();\nconst loginAttempts = new Map();\nconst accountLockouts = new Map();\nconst securitySettings = new Map();\nclass AuthService {\n    // Generate a random 6-digit OTP\n    static generateOTP() {\n        return Math.floor(100000 + Math.random() * 900000).toString();\n    }\n    // Hash password using bcrypt\n    static async hashPassword(password) {\n        return bcryptjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].hash(password, 12);\n    }\n    // Verify password\n    static async verifyPassword(password, hash) {\n        return bcryptjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].compare(password, hash);\n    }\n    // Register new user\n    static async registerUser(username, email, phone, password) {\n        // Check if user already exists\n        const existingUser = Array.from(users.values()).find((user)=>user.username === username || user.email === email || user.phone === phone);\n        if (existingUser) {\n            return {\n                success: false,\n                message: \"User already exists with this username, email, or phone\"\n            };\n        }\n        // Create new user\n        const userId = crypto__WEBPACK_IMPORTED_MODULE_1___default().randomUUID();\n        const passwordHash = await this.hashPassword(password);\n        const newUser = {\n            id: userId,\n            username,\n            email,\n            phone,\n            passwordHash,\n            createdAt: new Date()\n        };\n        users.set(userId, newUser);\n        return {\n            success: true,\n            message: \"User registered successfully\",\n            userId\n        };\n    }\n    // Login user\n    static async loginUser(username, password, deviceInfo) {\n        const user = Array.from(users.values()).find((u)=>u.username === username);\n        if (!user) {\n            return {\n                success: false,\n                message: \"Invalid username or password\"\n            };\n        }\n        // Check if account is locked\n        const lockoutTime = accountLockouts.get(user.id);\n        if (lockoutTime && new Date() < lockoutTime) {\n            const remainingMinutes = Math.ceil((lockoutTime.getTime() - Date.now()) / (1000 * 60));\n            return {\n                success: false,\n                message: \"Account locked. Try again in \".concat(remainingMinutes, \" minutes.\"),\n                isLocked: true\n            };\n        }\n        const isValidPassword = await this.verifyPassword(password, user.passwordHash);\n        // Record login attempt\n        const attempt = {\n            timestamp: new Date(),\n            success: isValidPassword,\n            ipAddress: deviceInfo === null || deviceInfo === void 0 ? void 0 : deviceInfo.ipAddress,\n            userAgent: deviceInfo === null || deviceInfo === void 0 ? void 0 : deviceInfo.userAgent\n        };\n        const userAttempts = loginAttempts.get(user.id) || [];\n        userAttempts.push(attempt);\n        loginAttempts.set(user.id, userAttempts.slice(-10)) // Keep last 10 attempts\n        ;\n        if (!isValidPassword) {\n            // Check for account lockout (5 failed attempts in 15 minutes)\n            const recentFailures = userAttempts.filter((a)=>!a.success && new Date().getTime() - a.timestamp.getTime() < 15 * 60 * 1000);\n            if (recentFailures.length >= 5) {\n                accountLockouts.set(user.id, new Date(Date.now() + 30 * 60 * 1000)) // Lock for 30 minutes\n                ;\n                return {\n                    success: false,\n                    message: \"Too many failed attempts. Account locked for 30 minutes.\",\n                    isLocked: true\n                };\n            }\n            return {\n                success: false,\n                message: \"Invalid username or password\"\n            };\n        }\n        // Clear lockout on successful login\n        accountLockouts.delete(user.id);\n        // Store user for biometric authentication on successful login\n        this.storeUserForBiometric(user.id);\n        return {\n            success: true,\n            message: \"Login successful\",\n            userId: user.id\n        };\n    }\n    // Generate and store OTP for user\n    static generateOTPForUser(userId) {\n        const otp = this.generateOTP();\n        const expiresAt = new Date(Date.now() + 60 * 1000) // 60 seconds from now\n        ;\n        otpSessions.set(userId, {\n            userId,\n            otp,\n            expiresAt,\n            attempts: 0\n        });\n        // For prototype: log OTP to console\n        console.log(\"[2FA Prototype] OTP for user \".concat(userId, \": \").concat(otp));\n        return {\n            otp,\n            expiresAt\n        };\n    }\n    // Verify OTP\n    static verifyOTP(userId, inputOTP) {\n        const session = otpSessions.get(userId);\n        if (!session) {\n            return {\n                success: false,\n                message: \"No OTP session found. Please request a new OTP.\"\n            };\n        }\n        // Check if OTP is expired\n        if (new Date() > session.expiresAt) {\n            otpSessions.delete(userId);\n            return {\n                success: false,\n                message: \"OTP has expired. Please request a new one.\"\n            };\n        }\n        // Increment attempts\n        session.attempts++;\n        // Check if too many attempts\n        if (session.attempts > 3) {\n            otpSessions.delete(userId);\n            return {\n                success: false,\n                message: \"Too many failed attempts. Please request a new OTP.\"\n            };\n        }\n        // Verify OTP\n        if (session.otp !== inputOTP) {\n            return {\n                success: false,\n                message: \"Invalid OTP. Please try again.\"\n            };\n        }\n        // Success - clean up session\n        otpSessions.delete(userId);\n        return {\n            success: true,\n            message: \"OTP verified successfully\"\n        };\n    }\n    // Get user by ID\n    static getUser(userId) {\n        return users.get(userId);\n    }\n    // Get remaining OTP time\n    static getOTPTimeRemaining(userId) {\n        const session = otpSessions.get(userId);\n        if (!session) return 0;\n        const remaining = session.expiresAt.getTime() - Date.now();\n        return Math.max(0, Math.floor(remaining / 1000));\n    }\n    // Get login history\n    static getLoginHistory(userId) {\n        return loginAttempts.get(userId) || [];\n    }\n    // Get security settings\n    static getSecuritySettings(userId) {\n        return securitySettings.get(userId) || {\n            twoFactorEnabled: true,\n            trustedDevices: [],\n            sessionTimeout: 30,\n            loginNotifications: true\n        };\n    }\n    // Update security settings\n    static updateSecuritySettings(userId, settings) {\n        const current = this.getSecuritySettings(userId);\n        securitySettings.set(userId, {\n            ...current,\n            ...settings\n        });\n    }\n    // Store user in localStorage for biometric authentication\n    static storeUserForBiometric(userId) {\n        if (true) {\n            localStorage.setItem(\"biometric_user_id\", userId);\n        }\n    }\n    // Get stored user for biometric authentication\n    static getStoredBiometricUser() {\n        if (true) {\n            return localStorage.getItem(\"biometric_user_id\");\n        }\n        return null;\n    }\n    // Remove stored biometric user\n    static removeStoredBiometricUser() {\n        if (true) {\n            localStorage.removeItem(\"biometric_user_id\");\n        }\n    }\n    // Biometric authentication using stored user\n    static authenticateWithBiometric() {\n        const storedUserId = this.getStoredBiometricUser();\n        if (!storedUserId) {\n            return {\n                success: false,\n                message: \"No biometric user found. Please login with username and password first.\"\n            };\n        }\n        const user = this.getUser(storedUserId);\n        if (!user) {\n            // Clean up invalid stored user\n            this.removeStoredBiometricUser();\n            return {\n                success: false,\n                message: \"Stored user not found. Please login with username and password.\"\n            };\n        }\n        // Record successful biometric login attempt\n        const attempt = {\n            timestamp: new Date(),\n            success: true,\n            ipAddress: \"biometric\",\n            userAgent: \"biometric-auth\"\n        };\n        const userAttempts = loginAttempts.get(storedUserId) || [];\n        userAttempts.push(attempt);\n        loginAttempts.set(storedUserId, userAttempts.slice(-10));\n        return {\n            success: true,\n            message: \"Biometric authentication successful\",\n            userId: storedUserId\n        };\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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ZSxJQUFJLENBQUNMLHNCQUFzQjtRQUVoRCxJQUFJLENBQUNLLGNBQWM7WUFDakIsT0FBTztnQkFDTC9ELFNBQVM7Z0JBQ1RDLFNBQVM7WUFDWDtRQUNGO1FBRUEsTUFBTUYsT0FBTyxJQUFJLENBQUM0QyxPQUFPLENBQUNvQjtRQUMxQixJQUFJLENBQUNoRSxNQUFNO1lBQ1QsK0JBQStCO1lBQy9CLElBQUksQ0FBQzZELHlCQUF5QjtZQUM5QixPQUFPO2dCQUNMNUQsU0FBUztnQkFDVEMsU0FBUztZQUNYO1FBQ0Y7UUFFQSw0Q0FBNEM7UUFDNUMsTUFBTW9CLFVBQXdCO1lBQzVCQyxXQUFXLElBQUlkO1lBQ2ZSLFNBQVM7WUFDVHVCLFdBQVc7WUFDWEMsV0FBVztRQUNiO1FBRUEsTUFBTUMsZUFBZWpELGNBQWNzQyxHQUFHLENBQUNpRCxpQkFBaUIsRUFBRTtRQUMxRHRDLGFBQWFDLElBQUksQ0FBQ0w7UUFDbEI3QyxjQUFjaUMsR0FBRyxDQUFDc0QsY0FBY3RDLGFBQWFFLEtBQUssQ0FBQyxDQUFDO1FBRXBELE9BQU87WUFDTDNCLFNBQVM7WUFDVEMsU0FBUztZQUNUQyxRQUFRNkQ7UUFDVjtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIi93b3Jrc3BhY2VzL2F1dGhhcHAvbGliL2F1dGgudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGJjcnlwdCBmcm9tIFwiYmNyeXB0anNcIlxuaW1wb3J0IGNyeXB0byBmcm9tIFwiY3J5cHRvXCJcbmltcG9ydCB7IHY0IGFzIHV1aWR2NCB9IGZyb20gXCJ1dWlkXCJcblxuZXhwb3J0IGludGVyZmFjZSBVc2VyIHtcbiAgaWQ6IHN0cmluZ1xuICB1c2VybmFtZTogc3RyaW5nXG4gIGVtYWlsOiBzdHJpbmdcbiAgcGhvbmU6IHN0cmluZ1xuICBwYXNzd29yZEhhc2g6IHN0cmluZ1xuICBjcmVhdGVkQXQ6IERhdGVcbn1cblxuZXhwb3J0IGludGVyZmFjZSBPVFBTZXNzaW9uIHtcbiAgdXNlcklkOiBzdHJpbmdcbiAgb3RwOiBzdHJpbmdcbiAgZXhwaXJlc0F0OiBEYXRlXG4gIGF0dGVtcHRzOiBudW1iZXJcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMb2dpbkF0dGVtcHQge1xuICB0aW1lc3RhbXA6IERhdGVcbiAgc3VjY2VzczogYm9vbGVhblxuICBpcEFkZHJlc3M/OiBzdHJpbmdcbiAgdXNlckFnZW50Pzogc3RyaW5nXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2VjdXJpdHlTZXR0aW5ncyB7XG4gIHR3b0ZhY3RvckVuYWJsZWQ6IGJvb2xlYW5cbiAgdHJ1c3RlZERldmljZXM6IHN0cmluZ1tdXG4gIHNlc3Npb25UaW1lb3V0OiBudW1iZXJcbiAgbG9naW5Ob3RpZmljYXRpb25zOiBib29sZWFuXG59XG5cbi8vIEluLW1lbW9yeSBzdG9yYWdlIGZvciBwcm90b3R5cGVcbmNvbnN0IHVzZXJzOiBNYXA8c3RyaW5nLCBVc2VyPiA9IG5ldyBNYXAoKVxuY29uc3Qgb3RwU2Vzc2lvbnM6IE1hcDxzdHJpbmcsIE9UUFNlc3Npb24+ID0gbmV3IE1hcCgpXG5jb25zdCBsb2dpbkF0dGVtcHRzOiBNYXA8c3RyaW5nLCBMb2dpbkF0dGVtcHRbXT4gPSBuZXcgTWFwKClcbmNvbnN0IGFjY291bnRMb2Nrb3V0czogTWFwPHN0cmluZywgRGF0ZT4gPSBuZXcgTWFwKClcbmNvbnN0IHNlY3VyaXR5U2V0dGluZ3M6IE1hcDxzdHJpbmcsIFNlY3VyaXR5U2V0dGluZ3M+ID0gbmV3IE1hcCgpXG5cbmV4cG9ydCBjbGFzcyBBdXRoU2VydmljZSB7XG4gIC8vIEdlbmVyYXRlIGEgcmFuZG9tIDYtZGlnaXQgT1RQXG4gIHN0YXRpYyBnZW5lcmF0ZU9UUCgpOiBzdHJpbmcge1xuICAgIHJldHVybiBNYXRoLmZsb29yKDEwMDAwMCArIE1hdGgucmFuZG9tKCkgKiA5MDAwMDApLnRvU3RyaW5nKClcbiAgfVxuXG4gIC8vIEhhc2ggcGFzc3dvcmQgdXNpbmcgYmNyeXB0XG4gIHN0YXRpYyBhc3luYyBoYXNoUGFzc3dvcmQocGFzc3dvcmQ6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgcmV0dXJuIGJjcnlwdC5oYXNoKHBhc3N3b3JkLCAxMilcbiAgfVxuXG4gIC8vIFZlcmlmeSBwYXNzd29yZFxuICBzdGF0aWMgYXN5bmMgdmVyaWZ5UGFzc3dvcmQocGFzc3dvcmQ6IHN0cmluZywgaGFzaDogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgcmV0dXJuIGJjcnlwdC5jb21wYXJlKHBhc3N3b3JkLCBoYXNoKVxuICB9XG5cbiAgLy8gUmVnaXN0ZXIgbmV3IHVzZXJcbiAgc3RhdGljIGFzeW5jIHJlZ2lzdGVyVXNlcihcbiAgICB1c2VybmFtZTogc3RyaW5nLFxuICAgIGVtYWlsOiBzdHJpbmcsXG4gICAgcGhvbmU6IHN0cmluZyxcbiAgICBwYXNzd29yZDogc3RyaW5nLFxuICApOiBQcm9taXNlPHsgc3VjY2VzczogYm9vbGVhbjsgbWVzc2FnZTogc3RyaW5nOyB1c2VySWQ/OiBzdHJpbmcgfT4ge1xuICAgIC8vIENoZWNrIGlmIHVzZXIgYWxyZWFkeSBleGlzdHNcbiAgICBjb25zdCBleGlzdGluZ1VzZXIgPSBBcnJheS5mcm9tKHVzZXJzLnZhbHVlcygpKS5maW5kKFxuICAgICAgKHVzZXIpID0+IHVzZXIudXNlcm5hbWUgPT09IHVzZXJuYW1lIHx8IHVzZXIuZW1haWwgPT09IGVtYWlsIHx8IHVzZXIucGhvbmUgPT09IHBob25lLFxuICAgIClcblxuICAgIGlmIChleGlzdGluZ1VzZXIpIHtcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBtZXNzYWdlOiBcIlVzZXIgYWxyZWFkeSBleGlzdHMgd2l0aCB0aGlzIHVzZXJuYW1lLCBlbWFpbCwgb3IgcGhvbmVcIiB9XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIG5ldyB1c2VyXG4gICAgY29uc3QgdXNlcklkID0gY3J5cHRvLnJhbmRvbVVVSUQoKVxuICAgIGNvbnN0IHBhc3N3b3JkSGFzaCA9IGF3YWl0IHRoaXMuaGFzaFBhc3N3b3JkKHBhc3N3b3JkKVxuXG4gICAgY29uc3QgbmV3VXNlcjogVXNlciA9IHtcbiAgICAgIGlkOiB1c2VySWQsXG4gICAgICB1c2VybmFtZSxcbiAgICAgIGVtYWlsLFxuICAgICAgcGhvbmUsXG4gICAgICBwYXNzd29yZEhhc2gsXG4gICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCksXG4gICAgfVxuXG4gICAgdXNlcnMuc2V0KHVzZXJJZCwgbmV3VXNlcilcbiAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBtZXNzYWdlOiBcIlVzZXIgcmVnaXN0ZXJlZCBzdWNjZXNzZnVsbHlcIiwgdXNlcklkIH1cbiAgfVxuXG4gIC8vIExvZ2luIHVzZXJcbiAgc3RhdGljIGFzeW5jIGxvZ2luVXNlcihcbiAgICB1c2VybmFtZTogc3RyaW5nLFxuICAgIHBhc3N3b3JkOiBzdHJpbmcsXG4gICAgZGV2aWNlSW5mbz86IHsgaXBBZGRyZXNzPzogc3RyaW5nOyB1c2VyQWdlbnQ/OiBzdHJpbmcgfSxcbiAgKTogUHJvbWlzZTx7IHN1Y2Nlc3M6IGJvb2xlYW47IG1lc3NhZ2U6IHN0cmluZzsgdXNlcklkPzogc3RyaW5nOyBpc0xvY2tlZD86IGJvb2xlYW4gfT4ge1xuICAgIGNvbnN0IHVzZXIgPSBBcnJheS5mcm9tKHVzZXJzLnZhbHVlcygpKS5maW5kKCh1KSA9PiB1LnVzZXJuYW1lID09PSB1c2VybmFtZSlcblxuICAgIGlmICghdXNlcikge1xuICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIG1lc3NhZ2U6IFwiSW52YWxpZCB1c2VybmFtZSBvciBwYXNzd29yZFwiIH1cbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiBhY2NvdW50IGlzIGxvY2tlZFxuICAgIGNvbnN0IGxvY2tvdXRUaW1lID0gYWNjb3VudExvY2tvdXRzLmdldCh1c2VyLmlkKVxuICAgIGlmIChsb2Nrb3V0VGltZSAmJiBuZXcgRGF0ZSgpIDwgbG9ja291dFRpbWUpIHtcbiAgICAgIGNvbnN0IHJlbWFpbmluZ01pbnV0ZXMgPSBNYXRoLmNlaWwoKGxvY2tvdXRUaW1lLmdldFRpbWUoKSAtIERhdGUubm93KCkpIC8gKDEwMDAgKiA2MCkpXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgbWVzc2FnZTogYEFjY291bnQgbG9ja2VkLiBUcnkgYWdhaW4gaW4gJHtyZW1haW5pbmdNaW51dGVzfSBtaW51dGVzLmAsXG4gICAgICAgIGlzTG9ja2VkOiB0cnVlLFxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGlzVmFsaWRQYXNzd29yZCA9IGF3YWl0IHRoaXMudmVyaWZ5UGFzc3dvcmQocGFzc3dvcmQsIHVzZXIucGFzc3dvcmRIYXNoKVxuXG4gICAgLy8gUmVjb3JkIGxvZ2luIGF0dGVtcHRcbiAgICBjb25zdCBhdHRlbXB0OiBMb2dpbkF0dGVtcHQgPSB7XG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCksXG4gICAgICBzdWNjZXNzOiBpc1ZhbGlkUGFzc3dvcmQsXG4gICAgICBpcEFkZHJlc3M6IGRldmljZUluZm8/LmlwQWRkcmVzcyxcbiAgICAgIHVzZXJBZ2VudDogZGV2aWNlSW5mbz8udXNlckFnZW50LFxuICAgIH1cblxuICAgIGNvbnN0IHVzZXJBdHRlbXB0cyA9IGxvZ2luQXR0ZW1wdHMuZ2V0KHVzZXIuaWQpIHx8IFtdXG4gICAgdXNlckF0dGVtcHRzLnB1c2goYXR0ZW1wdClcbiAgICBsb2dpbkF0dGVtcHRzLnNldCh1c2VyLmlkLCB1c2VyQXR0ZW1wdHMuc2xpY2UoLTEwKSkgLy8gS2VlcCBsYXN0IDEwIGF0dGVtcHRzXG5cbiAgICBpZiAoIWlzVmFsaWRQYXNzd29yZCkge1xuICAgICAgLy8gQ2hlY2sgZm9yIGFjY291bnQgbG9ja291dCAoNSBmYWlsZWQgYXR0ZW1wdHMgaW4gMTUgbWludXRlcylcbiAgICAgIGNvbnN0IHJlY2VudEZhaWx1cmVzID0gdXNlckF0dGVtcHRzLmZpbHRlcihcbiAgICAgICAgKGEpID0+ICFhLnN1Y2Nlc3MgJiYgbmV3IERhdGUoKS5nZXRUaW1lKCkgLSBhLnRpbWVzdGFtcC5nZXRUaW1lKCkgPCAxNSAqIDYwICogMTAwMCxcbiAgICAgIClcblxuICAgICAgaWYgKHJlY2VudEZhaWx1cmVzLmxlbmd0aCA+PSA1KSB7XG4gICAgICAgIGFjY291bnRMb2Nrb3V0cy5zZXQodXNlci5pZCwgbmV3IERhdGUoRGF0ZS5ub3coKSArIDMwICogNjAgKiAxMDAwKSkgLy8gTG9jayBmb3IgMzAgbWludXRlc1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgIG1lc3NhZ2U6IFwiVG9vIG1hbnkgZmFpbGVkIGF0dGVtcHRzLiBBY2NvdW50IGxvY2tlZCBmb3IgMzAgbWludXRlcy5cIixcbiAgICAgICAgICBpc0xvY2tlZDogdHJ1ZSxcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgbWVzc2FnZTogXCJJbnZhbGlkIHVzZXJuYW1lIG9yIHBhc3N3b3JkXCIgfVxuICAgIH1cblxuICAgIC8vIENsZWFyIGxvY2tvdXQgb24gc3VjY2Vzc2Z1bCBsb2dpblxuICAgIGFjY291bnRMb2Nrb3V0cy5kZWxldGUodXNlci5pZClcblxuICAgIC8vIFN0b3JlIHVzZXIgZm9yIGJpb21ldHJpYyBhdXRoZW50aWNhdGlvbiBvbiBzdWNjZXNzZnVsIGxvZ2luXG4gICAgdGhpcy5zdG9yZVVzZXJGb3JCaW9tZXRyaWModXNlci5pZClcblxuICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIG1lc3NhZ2U6IFwiTG9naW4gc3VjY2Vzc2Z1bFwiLCB1c2VySWQ6IHVzZXIuaWQgfVxuICB9XG5cbiAgLy8gR2VuZXJhdGUgYW5kIHN0b3JlIE9UUCBmb3IgdXNlclxuICBzdGF0aWMgZ2VuZXJhdGVPVFBGb3JVc2VyKHVzZXJJZDogc3RyaW5nKTogeyBvdHA6IHN0cmluZzsgZXhwaXJlc0F0OiBEYXRlIH0ge1xuICAgIGNvbnN0IG90cCA9IHRoaXMuZ2VuZXJhdGVPVFAoKVxuICAgIGNvbnN0IGV4cGlyZXNBdCA9IG5ldyBEYXRlKERhdGUubm93KCkgKyA2MCAqIDEwMDApIC8vIDYwIHNlY29uZHMgZnJvbSBub3dcblxuICAgIG90cFNlc3Npb25zLnNldCh1c2VySWQsIHtcbiAgICAgIHVzZXJJZCxcbiAgICAgIG90cCxcbiAgICAgIGV4cGlyZXNBdCxcbiAgICAgIGF0dGVtcHRzOiAwLFxuICAgIH0pXG5cbiAgICAvLyBGb3IgcHJvdG90eXBlOiBsb2cgT1RQIHRvIGNvbnNvbGVcbiAgICBjb25zb2xlLmxvZyhgWzJGQSBQcm90b3R5cGVdIE9UUCBmb3IgdXNlciAke3VzZXJJZH06ICR7b3RwfWApXG5cbiAgICByZXR1cm4geyBvdHAsIGV4cGlyZXNBdCB9XG4gIH1cblxuICAvLyBWZXJpZnkgT1RQXG4gIHN0YXRpYyB2ZXJpZnlPVFAodXNlcklkOiBzdHJpbmcsIGlucHV0T1RQOiBzdHJpbmcpOiB7IHN1Y2Nlc3M6IGJvb2xlYW47IG1lc3NhZ2U6IHN0cmluZyB9IHtcbiAgICBjb25zdCBzZXNzaW9uID0gb3RwU2Vzc2lvbnMuZ2V0KHVzZXJJZClcblxuICAgIGlmICghc2Vzc2lvbikge1xuICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIG1lc3NhZ2U6IFwiTm8gT1RQIHNlc3Npb24gZm91bmQuIFBsZWFzZSByZXF1ZXN0IGEgbmV3IE9UUC5cIiB9XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgT1RQIGlzIGV4cGlyZWRcbiAgICBpZiAobmV3IERhdGUoKSA+IHNlc3Npb24uZXhwaXJlc0F0KSB7XG4gICAgICBvdHBTZXNzaW9ucy5kZWxldGUodXNlcklkKVxuICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIG1lc3NhZ2U6IFwiT1RQIGhhcyBleHBpcmVkLiBQbGVhc2UgcmVxdWVzdCBhIG5ldyBvbmUuXCIgfVxuICAgIH1cblxuICAgIC8vIEluY3JlbWVudCBhdHRlbXB0c1xuICAgIHNlc3Npb24uYXR0ZW1wdHMrK1xuXG4gICAgLy8gQ2hlY2sgaWYgdG9vIG1hbnkgYXR0ZW1wdHNcbiAgICBpZiAoc2Vzc2lvbi5hdHRlbXB0cyA+IDMpIHtcbiAgICAgIG90cFNlc3Npb25zLmRlbGV0ZSh1c2VySWQpXG4gICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgbWVzc2FnZTogXCJUb28gbWFueSBmYWlsZWQgYXR0ZW1wdHMuIFBsZWFzZSByZXF1ZXN0IGEgbmV3IE9UUC5cIiB9XG4gICAgfVxuXG4gICAgLy8gVmVyaWZ5IE9UUFxuICAgIGlmIChzZXNzaW9uLm90cCAhPT0gaW5wdXRPVFApIHtcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBtZXNzYWdlOiBcIkludmFsaWQgT1RQLiBQbGVhc2UgdHJ5IGFnYWluLlwiIH1cbiAgICB9XG5cbiAgICAvLyBTdWNjZXNzIC0gY2xlYW4gdXAgc2Vzc2lvblxuICAgIG90cFNlc3Npb25zLmRlbGV0ZSh1c2VySWQpXG4gICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgbWVzc2FnZTogXCJPVFAgdmVyaWZpZWQgc3VjY2Vzc2Z1bGx5XCIgfVxuICB9XG5cbiAgLy8gR2V0IHVzZXIgYnkgSURcbiAgc3RhdGljIGdldFVzZXIodXNlcklkOiBzdHJpbmcpOiBVc2VyIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdXNlcnMuZ2V0KHVzZXJJZClcbiAgfVxuXG4gIC8vIEdldCByZW1haW5pbmcgT1RQIHRpbWVcbiAgc3RhdGljIGdldE9UUFRpbWVSZW1haW5pbmcodXNlcklkOiBzdHJpbmcpOiBudW1iZXIge1xuICAgIGNvbnN0IHNlc3Npb24gPSBvdHBTZXNzaW9ucy5nZXQodXNlcklkKVxuICAgIGlmICghc2Vzc2lvbikgcmV0dXJuIDBcblxuICAgIGNvbnN0IHJlbWFpbmluZyA9IHNlc3Npb24uZXhwaXJlc0F0LmdldFRpbWUoKSAtIERhdGUubm93KClcbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5mbG9vcihyZW1haW5pbmcgLyAxMDAwKSlcbiAgfVxuXG4gIC8vIEdldCBsb2dpbiBoaXN0b3J5XG4gIHN0YXRpYyBnZXRMb2dpbkhpc3RvcnkodXNlcklkOiBzdHJpbmcpOiBMb2dpbkF0dGVtcHRbXSB7XG4gICAgcmV0dXJuIGxvZ2luQXR0ZW1wdHMuZ2V0KHVzZXJJZCkgfHwgW11cbiAgfVxuXG4gIC8vIEdldCBzZWN1cml0eSBzZXR0aW5nc1xuICBzdGF0aWMgZ2V0U2VjdXJpdHlTZXR0aW5ncyh1c2VySWQ6IHN0cmluZyk6IFNlY3VyaXR5U2V0dGluZ3Mge1xuICAgIHJldHVybiAoXG4gICAgICBzZWN1cml0eVNldHRpbmdzLmdldCh1c2VySWQpIHx8IHtcbiAgICAgICAgdHdvRmFjdG9yRW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgdHJ1c3RlZERldmljZXM6IFtdLFxuICAgICAgICBzZXNzaW9uVGltZW91dDogMzAsXG4gICAgICAgIGxvZ2luTm90aWZpY2F0aW9uczogdHJ1ZSxcbiAgICAgIH1cbiAgICApXG4gIH1cblxuICAvLyBVcGRhdGUgc2VjdXJpdHkgc2V0dGluZ3NcbiAgc3RhdGljIHVwZGF0ZVNlY3VyaXR5U2V0dGluZ3ModXNlcklkOiBzdHJpbmcsIHNldHRpbmdzOiBQYXJ0aWFsPFNlY3VyaXR5U2V0dGluZ3M+KTogdm9pZCB7XG4gICAgY29uc3QgY3VycmVudCA9IHRoaXMuZ2V0U2VjdXJpdHlTZXR0aW5ncyh1c2VySWQpXG4gICAgc2VjdXJpdHlTZXR0aW5ncy5zZXQodXNlcklkLCB7IC4uLmN1cnJlbnQsIC4uLnNldHRpbmdzIH0pXG4gIH1cblxuICAvLyBTdG9yZSB1c2VyIGluIGxvY2FsU3RvcmFnZSBmb3IgYmlvbWV0cmljIGF1dGhlbnRpY2F0aW9uXG4gIHN0YXRpYyBzdG9yZVVzZXJGb3JCaW9tZXRyaWModXNlcklkOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJiaW9tZXRyaWNfdXNlcl9pZFwiLCB1c2VySWQpXG4gICAgfVxuICB9XG5cbiAgLy8gR2V0IHN0b3JlZCB1c2VyIGZvciBiaW9tZXRyaWMgYXV0aGVudGljYXRpb25cbiAgc3RhdGljIGdldFN0b3JlZEJpb21ldHJpY1VzZXIoKTogc3RyaW5nIHwgbnVsbCB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcImJpb21ldHJpY191c2VyX2lkXCIpXG4gICAgfVxuICAgIHJldHVybiBudWxsXG4gIH1cblxuICAvLyBSZW1vdmUgc3RvcmVkIGJpb21ldHJpYyB1c2VyXG4gIHN0YXRpYyByZW1vdmVTdG9yZWRCaW9tZXRyaWNVc2VyKCk6IHZvaWQge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShcImJpb21ldHJpY191c2VyX2lkXCIpXG4gICAgfVxuICB9XG5cbiAgLy8gQmlvbWV0cmljIGF1dGhlbnRpY2F0aW9uIHVzaW5nIHN0b3JlZCB1c2VyXG4gIHN0YXRpYyBhdXRoZW50aWNhdGVXaXRoQmlvbWV0cmljKCk6IHsgc3VjY2VzczogYm9vbGVhbjsgbWVzc2FnZTogc3RyaW5nOyB1c2VySWQ/OiBzdHJpbmcgfSB7XG4gICAgY29uc3Qgc3RvcmVkVXNlcklkID0gdGhpcy5nZXRTdG9yZWRCaW9tZXRyaWNVc2VyKClcblxuICAgIGlmICghc3RvcmVkVXNlcklkKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgbWVzc2FnZTogXCJObyBiaW9tZXRyaWMgdXNlciBmb3VuZC4gUGxlYXNlIGxvZ2luIHdpdGggdXNlcm5hbWUgYW5kIHBhc3N3b3JkIGZpcnN0LlwiLFxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHVzZXIgPSB0aGlzLmdldFVzZXIoc3RvcmVkVXNlcklkKVxuICAgIGlmICghdXNlcikge1xuICAgICAgLy8gQ2xlYW4gdXAgaW52YWxpZCBzdG9yZWQgdXNlclxuICAgICAgdGhpcy5yZW1vdmVTdG9yZWRCaW9tZXRyaWNVc2VyKClcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBtZXNzYWdlOiBcIlN0b3JlZCB1c2VyIG5vdCBmb3VuZC4gUGxlYXNlIGxvZ2luIHdpdGggdXNlcm5hbWUgYW5kIHBhc3N3b3JkLlwiLFxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlY29yZCBzdWNjZXNzZnVsIGJpb21ldHJpYyBsb2dpbiBhdHRlbXB0XG4gICAgY29uc3QgYXR0ZW1wdDogTG9naW5BdHRlbXB0ID0ge1xuICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLFxuICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgIGlwQWRkcmVzczogXCJiaW9tZXRyaWNcIixcbiAgICAgIHVzZXJBZ2VudDogXCJiaW9tZXRyaWMtYXV0aFwiLFxuICAgIH1cblxuICAgIGNvbnN0IHVzZXJBdHRlbXB0cyA9IGxvZ2luQXR0ZW1wdHMuZ2V0KHN0b3JlZFVzZXJJZCkgfHwgW11cbiAgICB1c2VyQXR0ZW1wdHMucHVzaChhdHRlbXB0KVxuICAgIGxvZ2luQXR0ZW1wdHMuc2V0KHN0b3JlZFVzZXJJZCwgdXNlckF0dGVtcHRzLnNsaWNlKC0xMCkpXG5cbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgIG1lc3NhZ2U6IFwiQmlvbWV0cmljIGF1dGhlbnRpY2F0aW9uIHN1Y2Nlc3NmdWxcIixcbiAgICAgIHVzZXJJZDogc3RvcmVkVXNlcklkLFxuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbImJjcnlwdCIsImNyeXB0byIsInVzZXJzIiwiTWFwIiwib3RwU2Vzc2lvbnMiLCJsb2dpbkF0dGVtcHRzIiwiYWNjb3VudExvY2tvdXRzIiwic2VjdXJpdHlTZXR0aW5ncyIsIkF1dGhTZXJ2aWNlIiwiZ2VuZXJhdGVPVFAiLCJNYXRoIiwiZmxvb3IiLCJyYW5kb20iLCJ0b1N0cmluZyIsImhhc2hQYXNzd29yZCIsInBhc3N3b3JkIiwiaGFzaCIsInZlcmlmeVBhc3N3b3JkIiwiY29tcGFyZSIsInJlZ2lzdGVyVXNlciIsInVzZXJuYW1lIiwiZW1haWwiLCJwaG9uZSIsImV4aXN0aW5nVXNlciIsIkFycmF5IiwiZnJvbSIsInZhbHVlcyIsImZpbmQiLCJ1c2VyIiwic3VjY2VzcyIsIm1lc3NhZ2UiLCJ1c2VySWQiLCJyYW5kb21VVUlEIiwicGFzc3dvcmRIYXNoIiwibmV3VXNlciIsImlkIiwiY3JlYXRlZEF0IiwiRGF0ZSIsInNldCIsImxvZ2luVXNlciIsImRldmljZUluZm8iLCJ1IiwibG9ja291dFRpbWUiLCJnZXQiLCJyZW1haW5pbmdNaW51dGVzIiwiY2VpbCIsImdldFRpbWUiLCJub3ciLCJpc0xvY2tlZCIsImlzVmFsaWRQYXNzd29yZCIsImF0dGVtcHQiLCJ0aW1lc3RhbXAiLCJpcEFkZHJlc3MiLCJ1c2VyQWdlbnQiLCJ1c2VyQXR0ZW1wdHMiLCJwdXNoIiwic2xpY2UiLCJyZWNlbnRGYWlsdXJlcyIsImZpbHRlciIsImEiLCJsZW5ndGgiLCJkZWxldGUiLCJzdG9yZVVzZXJGb3JCaW9tZXRyaWMiLCJnZW5lcmF0ZU9UUEZvclVzZXIiLCJvdHAiLCJleHBpcmVzQXQiLCJhdHRlbXB0cyIsImNvbnNvbGUiLCJsb2ciLCJ2ZXJpZnlPVFAiLCJpbnB1dE9UUCIsInNlc3Npb24iLCJnZXRVc2VyIiwiZ2V0T1RQVGltZVJlbWFpbmluZyIsInJlbWFpbmluZyIsIm1heCIsImdldExvZ2luSGlzdG9yeSIsImdldFNlY3VyaXR5U2V0dGluZ3MiLCJ0d29GYWN0b3JFbmFibGVkIiwidHJ1c3RlZERldmljZXMiLCJzZXNzaW9uVGltZW91dCIsImxvZ2luTm90aWZpY2F0aW9ucyIsInVwZGF0ZVNlY3VyaXR5U2V0dGluZ3MiLCJzZXR0aW5ncyIsImN1cnJlbnQiLCJsb2NhbFN0b3JhZ2UiLCJzZXRJdGVtIiwiZ2V0U3RvcmVkQmlvbWV0cmljVXNlciIsImdldEl0ZW0iLCJyZW1vdmVTdG9yZWRCaW9tZXRyaWNVc2VyIiwicmVtb3ZlSXRlbSIsImF1dGhlbnRpY2F0ZVdpdGhCaW9tZXRyaWMiLCJzdG9yZWRVc2VySWQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/auth.ts\n"));

/***/ })

});